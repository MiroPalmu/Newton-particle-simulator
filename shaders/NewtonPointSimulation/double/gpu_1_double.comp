
// The version to use 
#version 450
#extension GL_KHR_shader_subgroup_basic : enable
#extension GL_ARB_gpu_shader_fp64 : enable


// The execution structure
layout (local_size_x = 1) in;

layout (constant_id = 0) const double softening_radius = 0.1;
layout (constant_id = 1) const double G = 6.6743e-11;

// The buffers are provided via the tensors
layout(binding = 0) buffer bufA { double x_coordinates[]; };
layout(binding = 1) buffer bufB { double y_coordinates[]; };
layout(binding = 2) buffer bufC { double x_speeds[]; };
layout(binding = 3) buffer bufD { double y_speeds[]; };
layout(binding = 4) buffer bufE { double masses[]; };


layout( push_constant ) uniform constants {
    double timestep;
};

void main() {

    uint i = gl_GlobalInvocationID.x;
    uint particles = gl_NumWorkGroups.x * gl_WorkGroupSize.x;

    double x_acceleration = 0.0LF;
    double y_acceleration = 0.0LF;
    for (uint j = 0; j < particles; ++j) {
            
        if (i == j){
            continue;
        }

        const double d_x = x_coordinates[j] - x_coordinates[i];
        const double d_y = y_coordinates[j] - y_coordinates[i];
        
        const double d2 = d_x * d_x + d_y * d_y + softening_radius * softening_radius;


        x_acceleration += sign(d_x) * G * masses[j] / d2;
        y_acceleration += sign(d_y) * G * masses[j] / d2;

    }


    x_speeds[i] += x_acceleration * timestep;
    y_speeds[i] += y_acceleration * timestep;
    // New position from new velocity
    x_coordinates[i] += x_speeds[i] * timestep;
    y_coordinates[i] += y_speeds[i] * timestep;
        
} 
