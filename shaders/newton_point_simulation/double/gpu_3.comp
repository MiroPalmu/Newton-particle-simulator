
// The version to use 
#version 450
#extension GL_KHR_shader_subgroup_basic : enable
#extension GL_ARB_gpu_shader_fp64 : enable


// The execution structure
layout (local_size_x = 64) in;

/* Shader does not work if not specialized */
layout (constant_id = 0) const uint particles = 3000;

// The buffers are provided via the tensors
layout(binding = 0) buffer bufA { double x_coordinates[]; };
layout(binding = 1) buffer bufB { double y_coordinates[]; };
layout(binding = 2) buffer bufC { double x_speeds[]; };
layout(binding = 3) buffer bufD { double y_speeds[]; };
layout(binding = 4) buffer bufE { double masses[]; };

layout( push_constant ) uniform constants {
    double softening_radius;
    double G;
    double timestep;

};


void main() {

    const uint i = gl_GlobalInvocationID.x;

    double x_acceleration = 0.0LF;
    double y_acceleration = 0.0LF;

    const double own_x_coordinates = x_coordinates[i];
    const double own_y_coordinates = y_coordinates[i];

    for (uint j = 0; j < particles; ++j) {
        const double d_x = x_coordinates[j] - own_x_coordinates;
        const double d_y = y_coordinates[j] - own_y_coordinates;
        // We calculate this way because sign function is problematic
        // Results might differ between cpu and gpu
        const double d_inverted = inversesqrt(d_x * d_x + d_y * d_y + softening_radius * softening_radius);

        // There is no double pow function 
        x_acceleration = fma(d_x * G * masses[j], d_inverted * d_inverted * d_inverted, x_acceleration);
        y_acceleration = fma(d_y * G * masses[j], d_inverted * d_inverted * d_inverted, y_acceleration);
    }


    x_speeds[i] = fma(x_acceleration, timestep, x_speeds[i]);
    y_speeds[i] = fma(y_acceleration, timestep, y_speeds[i]);
        
} 
