
// The version to use 
#version 450
#extension GL_KHR_shader_subgroup_basic : enable


// The execution structure
layout (local_size_x = 64) in;

/* Shader does not work if not specialized */
layout (constant_id = 0) const uint particles = 3000;

// The buffers are provided via the tensors
layout(binding = 0) buffer bufA { float x_coordinates[]; };
layout(binding = 1) buffer bufB { float y_coordinates[]; };
layout(binding = 2) buffer bufC { float x_speeds[]; };
layout(binding = 3) buffer bufD { float y_speeds[]; };
layout(binding = 4) buffer bufE { float masses[]; };

layout( push_constant ) uniform constants {
    float softening_radius;
    float G;
    float timestep;

};


void main() {

    const uint i = gl_GlobalInvocationID.x;

    float x_acceleration = 0.0;
    float y_acceleration = 0.0;

    for (uint j = 0; j < particles; ++j) {
        const float d_x = x_coordinates[j] - x_coordinates[i];
        const float d_y = y_coordinates[j] - y_coordinates[i];
        // We calculate this way because sign function is problematic
        // Results might differ between cpu and gpu
        const float d = sqrt(d_x * d_x + d_y * d_y + softening_radius * softening_radius);

        // There is no float pow function 
        x_acceleration += d_x * G * masses[j] / (d * d * d);
        y_acceleration += d_y * G * masses[j] / (d * d * d);
    }


    x_speeds[i] += x_acceleration * timestep;
    y_speeds[i] += y_acceleration * timestep;
        
} 
